并发（信号、线程）
信号是初步异步
线程是强烈异步


一：信号

1：信号是什么？
信号是软件层面的中断
中断是底层的
信号是应用层面的

信号的相应依赖于中断这个机制

并发：同步 异步 

异步事件处理
(例如单核) 时间片会轮流调度多个进程    大脑是真正的异步

1：查询法    
2：通知法
 

2：信号函数
singal();
void (*signal(int signum,void (*func)(int)))(int);   

一、SIGINT、SIGTERM和SIGKILL区别

SIGINT与SIGTERM区别
1）SIGINT关联ctrl+c
2）SIGINT只能结束前台进程
3）通过ctrl+c对当前进程发送结束信号，信号被进程树接收到（即：不仅当前进程，子进程也会收到结束信号）
SIGTERM与SIGKILL
1）SIGTERM可以被阻塞、处理和忽略；因此有的进程不能按预期的结束
2）kill不使用参数：发送SIGTERM信号，只有当前进程收到信号，若当前进程被kill，则子进程的父进程就会更改为init，即pid为1
3）kill命令的默认不带参数发生的信号就是SIGTERM，让程序友好的退出 ，当程序未退出时，可以使用kill -9强制退出

信号会打断阻塞的系统调用


3:信号的不可靠
标准信号会丢失

信号不可靠是信号的行为不可靠
有可能是内核布置的，有可能第一次调用还没有结束的时候就发生了第二次调用

4：可重入函数
第一次调用还没有结束就发生了第二次调用，这样的现象称为重入函数
所有的系统调用都是可重入的，一部分库函数也是可重入的，如：memcpy memmove
例如：rand_r 就是不可重入的

5：信号的响应过程

内核为每一组进程维护了最少2个位图
1:mask
2pending
理论上这两个都是32位的，是标准信号的大小

信号从收到到响应有个不可避免的延迟
因为有中断将正在执行的信号打断，信号是从kernel 回到 user的路上相应的

思考：
信号如何忽略掉的
标准信号可以忽略掉
将mask位值为零

标准信号为什么要丢失？
来一万个信号置为1还是1

6:信号常用函数
kill()  //在这里是发信号的 kill
raise() //

alarm()
pause()
abort()
system()
sleep()
7:信号集
8：信号屏蔽字/pending集的处理
9：sigsuspend()
   sigaction()
   setitimer()
10:实时信号

二：线程





